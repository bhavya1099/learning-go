// ********RoostGPT********
/*
Test generated by RoostGPT for test go-unit-scenario-filter using AI Type Open AI and AI Model gpt-3.5-turbo

ROOST_METHOD_HASH=getCountArrayLength_78c814dcdc
ROOST_METHOD_SIG_HASH=getCountArrayLength_93c7685300

```go
Scenario 1: Test with a non-empty array

Details:
  Description: Test to verify the function behavior when provided with a non-empty array.
  Execution:
    Arrange: Prepare an array with multiple elements.
    Act: Call getCountArrayLength with the prepared array.
    Assert: Ensure the returned value is one more than the maximum value in the array.
  Validation:
    By passing a non-empty array, the test aims to verify that the function correctly calculates the length of the count array based on the maximum value present in the input array.

Scenario 2: Test with an empty array

Details:
  Description: Test to validate the function behavior when an empty array is provided as input.
  Execution:
    Arrange: Prepare an empty array.
    Act: Invoke getCountArrayLength with the empty array.
    Assert: Confirm that the function returns 1 for an empty array.
  Validation:
    This scenario ensures that the function handles the edge case of an empty array by returning 1, as specified in the function logic.

Scenario 3: Test with a single-element array

Details:
  Description: Test to check the function output for an array with a single element.
  Execution:
    Arrange: Prepare an array with a single element.
    Act: Call getCountArrayLength with the single-element array.
    Assert: Verify that the function returns the value of the single element plus 1.
  Validation:
    By providing an array with only one element, this test scenario validates if the function correctly calculates the count array length based on the single element's value.

Scenario 4: Test with a negative values array

Details:
  Description: Test to examine the function response when an array containing negative values is passed.
  Execution:
    Arrange: Prepare an array with negative integer values.
    Act: Execute getCountArrayLength with the array containing negative values.
    Assert: Check that the function returns one more than the maximum value (positive) present in the array.
  Validation:
    This scenario ensures that the function handles negative values correctly by considering the magnitude of the maximum positive value in the array.

Scenario 5: Test with a large array

Details:
  Description: Test the function with a large array to evaluate performance.
  Execution:
    Arrange: Create a large array with a significant number of elements.
    Act: Invoke getCountArrayLength with the large array.
    Assert: Validate that the function returns the correct count array length based on the maximum value in the large array.
  Validation:
    By testing the function with a large dataset, this scenario aims to assess the function's scalability and efficiency in handling a substantial number of elements in the input array.

```
*/

// ********RoostGPT********
package CountingSort

import (
	"testing"
)

func TestGetCountArrayLength(t *testing.T) {
	tests := []struct {
		name     string
		arr      []int
		expected int
	}{
		{
			name:     "Test with a non-empty array",
			arr:      []int{3, 6, 2, 8, 1},
			expected: 9,
		},
		{
			name:     "Test with an empty array",
			arr:      []int{},
			expected: 1,
		},
		{
			name:     "Test with a single-element array",
			arr:      []int{5},
			expected: 6,
		},
		{
			name:     "Test with a negative values array",
			arr:      []int{-3, -6, -2, -8, -1},
			expected: 9,
		},
		{
			name:     "Test with a large array",
			arr:      generateLargeArray(10000),
			expected: 10001,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := getCountArrayLength(test.arr)
			if actual != test.expected {
				t.Errorf("Test Case: %s - Expected: %d, Got: %d", test.name, test.expected, actual)
			} else {
				t.Logf("Test Case: %s - Passed", test.name)
			}
		})
	}
}

func generateLargeArray(size int) []int {
	arr := make([]int, size)
	for i := 0; i < size; i++ {
		arr[i] = i + 1
	}
	return arr
}

func getCountArrayLength(arr []int) int {
	if len(arr) == 0 {
		return 1
	}

	k := arr[0]

	for _, value := range arr {
		if value > k {
			k = value
		}
	}

	return k + 1
}
