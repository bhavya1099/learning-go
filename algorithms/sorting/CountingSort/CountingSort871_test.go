// ********RoostGPT********
/*
Test generated by RoostGPT for test go-unit-scenario-filter using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Note: Only generate test cases based on the given scenarios,dont not generate test cases other than these scenarios
Empty Array
Basic Functionality Test with Positive Numbers
*/

// ********RoostGPT********
package CountingSort

import (
	"testing"
)

// TestCountingSort871 tests the countingSort function with various scenarios
func TestCountingSort871(t *testing.T) {
	type testCase struct {
		input    []int
		expected []int
		desc     string
	}

	testCases := []testCase{
		{input: []int{}, expected: []int{}, desc: "Empty Array"},
		{input: []int{5, 3, 8, 6, 2}, expected: []int{2, 3, 5, 6, 8}, desc: "Basic Functionality Test with Positive Numbers"},
	}

	for _, tc := range testCases {
		result := countingSort(tc.input)
		if !equal(result, tc.expected) {
			t.Errorf("Test failed for: %s\nExpected %v, got %v", tc.desc, tc.expected, result)
		} else {
			t.Logf("Test passed for: %s\nExpected %v, got %v", tc.desc, tc.expected, result)
		}
	}
}

// equal checks if two slices are the same
func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

// countingSort sorts the array using counting sort algorithm
func countingSort(arr []int) []int {
	if len(arr) == 0 {
		return arr
	}

	k := getMax(arr) + 1
	count := make([]int, k)
	output := make([]int, len(arr))

	for i := 0; i < len(arr); i++ {
		count[arr[i]]++
	}

	for i := 1; i < k; i++ {
		count[i] += count[i-1]
	}

	for i := len(arr) - 1; i >= 0; i-- {
		output[count[arr[i]]-1] = arr[i]
		count[arr[i]]--
	}

	return output
}

// getMax returns the maximum value in an array
func getMax(arr []int) int {
	max := arr[0]
	for _, v := range arr {
		if v > max {
			max = v
		}
	}
	return max
}
