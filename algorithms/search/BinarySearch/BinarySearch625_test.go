// ********RoostGPT********
/*
Test generated by RoostGPT for test go-unit-scenario-filter using AI Type  and AI Model 

ROOST_METHOD_HASH=binarySearch_5149337a0e
ROOST_METHOD_SIG_HASH=binarySearch_7d22ad2576

Note: Only generate test cases based on the given scenarios,do not generate test cases other than these scenarios
Scenario 1: Query is the first element
Scenario 2: Query is the last element
Scenario 3: Query is less than the smallest element in the array
*/

// ********RoostGPT********
package BinarySearch

import (
	"bytes"
	"fmt"
	"os"
	"testing"
)

// Import binarySearch function from the BinarySearch package
// Assuming the function is available in the same package as this test file

func binarySearch(arr []int, query int) int {
	minIndex := 0
	maxIndex := len(arr) - 1
	for minIndex <= maxIndex {
		midIndex := int((maxIndex + minIndex) / 2)
		midItem := arr[midIndex]
		if query == midItem {
			return midIndex
		}
		if midItem < query {
			minIndex = midIndex + 1
		} else if midItem > query {
			maxIndex = midIndex - 1
		}
	}
	return -1
}

func TestBinarySearch625(t *testing.T) {
	type testCase struct {
		name     string
		arr      []int
		query    int
		expected int
	}

	testCases := []testCase{
		{
			name:     "QueryIsFirstElement",
			arr:      []int{1, 2, 3, 4, 5},
			query:    1,
			expected: 0,
		},
		{
			name:     "QueryIsLastElement",
			arr:      []int{1, 2, 3, 4, 5},
			query:    5,
			expected: 4,
		},
		{
			name:     "QueryLessThanSmallestElement",
			arr:      []int{5, 10, 15, 20},
			query:    1,
			expected: -1,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var buf bytes.Buffer
			old := os.Stdout
			os.Stdout = &buf
			defer func() { os.Stdout = old }()

			result := binarySearch(tc.arr, tc.query)

			if result != tc.expected {
				t.Errorf("FAIL %s: Expected %d, got %d", tc.name, tc.expected, result)
			} else {
				t.Logf("PASS %s: Correctly found %d at index %d", tc.name, tc.query, result)
			}

			var output string
			fmt.Fprintf(old, "Test case: %s\n", tc.name)
			fmt.Fscanf(&buf, "Test case: %s\n", &output)
			if output != tc.name {
				t.Errorf("Output mismatch: got %s, expected %s", output, tc.name)
			} else {
				t.Logf("Output correctly redirected for test case: %s", tc.name)
			}
		})
	}
}
