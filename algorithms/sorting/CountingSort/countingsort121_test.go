// ********RoostGPT********
/*
Test generated by RoostGPT for test go-unit-scenario-filter using AI Type Open AI and AI Model gpt-3.5-turbo

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

```go
Scenario 1: Test countingSort with a sorted input array

Details:
  Description: This test checks the function's behavior when provided with an already sorted input array.
  Execution:
    Arrange: Prepare an input array that is already sorted, e.g., arr := []int{1, 2, 3, 4, 5}.
    Act: Call countingSort(arr).
    Assert: Verify that the returned array is the same as the input array.
  Validation:
    The test ensures that the function does not alter the input when it is already sorted, confirming the stability of the counting sort algorithm.

Scenario 2: Test countingSort with a reverse-sorted input array

Details:
  Description: This test examines the function's performance when given a reverse-sorted input array.
  Execution:
    Arrange: Create a reverse-sorted input array, e.g., arr := []int{5, 4, 3, 2, 1}.
    Act: Invoke countingSort(arr).
    Assert: Validate that the returned array is sorted in ascending order.
  Validation:
    This test verifies the correctness of the algorithm in handling reverse-sorted input, ensuring that the function can sort arrays in any order.

Scenario 3: Test countingSort with a large input array

Details:
  Description: This test evaluates the function's scalability by using a large input array.
  Execution:
    Arrange: Generate a large array with random elements, e.g., arr := []int{1000, 500, 2000, 1500, ...}.
    Act: Run countingSort(arr).
    Assert: Check that the returned array is correctly sorted.
  Validation:
    The test assesses the algorithm's efficiency and ability to handle a significant number of elements without performance degradation.

Scenario 4: Test countingSort with an empty input array

Details:
  Description: This test scrutinizes the function's behavior when provided with an empty input array.
  Execution:
    Arrange: Prepare an empty array, e.g., arr := []int{}.
    Act: Call countingSort(arr).
    Assert: Ensure that the returned array is also empty.
  Validation:
    Verifying the function's response to an empty array is crucial for ensuring proper handling of edge cases and preventing potential runtime errors.

Scenario 5: Test countingSort with an array containing duplicate elements

Details:
  Description: This test examines the function's correctness when the input array contains duplicate elements.
  Execution:
    Arrange: Create an input array with duplicate values, e.g., arr := []int{2, 3, 2, 1, 3}.
    Act: Execute countingSort(arr).
    Assert: Validate that the returned array is sorted correctly with duplicate elements maintained in order.
  Validation:
    This test confirms that the counting sort algorithm preserves the order of duplicate elements, ensuring the stability of the sorting process.

Scenario 6: Test countingSort with a single-element input array

Details:
  Description: This test assesses the function's handling of a single-element input array.
  Execution:
    Arrange: Prepare a single-element array, e.g., arr := []int{5}.
    Act: Invoke countingSort(arr).
    Assert: Check that the returned array is the same as the input array.
  Validation:
    Testing with a single-element array ensures that the function can handle minimal input sizes effectively, validating its basic functionality.
```
*/

// ********RoostGPT********
package CountingSort

import (
	"reflect"
	"testing"
)

func Testcountingsort121(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		expected []int
	}{
		{
			name:     "Test countingSort with a sorted input array",
			input:    []int{1, 2, 3, 4, 5},
			expected: []int{1, 2, 3, 4, 5},
		},
		{
			name:     "Test countingSort with a reverse-sorted input array",
			input:    []int{5, 4, 3, 2, 1},
			expected: []int{1, 2, 3, 4, 5},
		},
		{
			name:     "Test countingSort with a large input array",
			input:    []int{1000, 500, 2000, 1500, 3000},
			expected: []int{500, 1000, 1500, 2000, 3000},
		},
		{
			name:     "Test countingSort with an empty input array",
			input:    []int{},
			expected: []int{},
		},
		{
			name:     "Test countingSort with an array containing duplicate elements",
			input:    []int{2, 3, 2, 1, 3},
			expected: []int{1, 2, 2, 3, 3},
		},
		{
			name:     "Test countingSort with a single-element input array",
			input:    []int{5},
			expected: []int{5},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := countingSort(tt.input)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("Test Case: %s failed. Expected: %v, Got: %v", tt.name, tt.expected, result)
			} else {
				t.Logf("Test Case: %s passed", tt.name)
			}
		})
	}
}

func countingSort(arr []int) []int {
	k := getCountArrayLength(arr)

	count := make([]int, k)

	for i := 0; i < len(arr); i++ {
		count[arr[i]] += 1
	}

	for i, j := 0, 0; i < k; i++ {
		for {
			if count[i] > 0 {
				arr[j] = i
				j += 1
				count[i] -= 1
				continue
			}
			break
		}
	}

	return arr
}

func getCountArrayLength(arr []int) int {
	if len(arr) == 0 {
		return 0
	}

	max := arr[0]
	for _, num := range arr {
		if num > max {
			max = num
		}
	}

	return max + 1
}
